import {
  Tensor,
  add,
  browser_exports,
  cast,
  concat2d,
  div,
  env,
  expandDims,
  getBackend,
  image,
  loadGraphModel,
  mul,
  reshape,
  sigmoid,
  slice,
  squeeze,
  sub,
  tensor1d,
  tensor2d,
  tidy,
  util_exports
} from "./chunk-DKVE4PTU.js";
import "./chunk-5WWUZCGV.js";

// node_modules/@tensorflow-models/handpose/dist/handpose.esm.js
function k(t, n, e, r) {
  return new (e || (e = Promise))(function(o, i) {
    function s(t2) {
      try {
        u(r.next(t2));
      } catch (t3) {
        i(t3);
      }
    }
    function a(t2) {
      try {
        u(r.throw(t2));
      } catch (t3) {
        i(t3);
      }
    }
    function u(t2) {
      var n2;
      t2.done ? o(t2.value) : (n2 = t2.value, n2 instanceof e ? n2 : new e(function(t3) {
        t3(n2);
      })).then(s, a);
    }
    u((r = r.apply(t, n || [])).next());
  });
}
function x(t, n) {
  var e, r, o, i, s = { label: 0, sent: function() {
    if (1 & o[0])
      throw o[1];
    return o[1];
  }, trys: [], ops: [] };
  return i = { next: a(0), throw: a(1), return: a(2) }, "function" == typeof Symbol && (i[Symbol.iterator] = function() {
    return this;
  }), i;
  function a(a2) {
    return function(u) {
      return function(a3) {
        if (e)
          throw new TypeError("Generator is already executing.");
        for (; i && (i = 0, a3[0] && (s = 0)), s; )
          try {
            if (e = 1, r && (o = 2 & a3[0] ? r.return : a3[0] ? r.throw || ((o = r.return) && o.call(r), 0) : r.next) && !(o = o.call(r, a3[1])).done)
              return o;
            switch (r = 0, o && (a3 = [2 & a3[0], o.value]), a3[0]) {
              case 0:
              case 1:
                o = a3;
                break;
              case 4:
                return s.label++, { value: a3[1], done: false };
              case 5:
                s.label++, r = a3[1], a3 = [0];
                continue;
              case 7:
                a3 = s.ops.pop(), s.trys.pop();
                continue;
              default:
                if (!(o = s.trys, (o = o.length > 0 && o[o.length - 1]) || 6 !== a3[0] && 2 !== a3[0])) {
                  s = 0;
                  continue;
                }
                if (3 === a3[0] && (!o || a3[1] > o[0] && a3[1] < o[3])) {
                  s.label = a3[1];
                  break;
                }
                if (6 === a3[0] && s.label < o[1]) {
                  s.label = o[1], o = a3;
                  break;
                }
                if (o && s.label < o[2]) {
                  s.label = o[2], s.ops.push(a3);
                  break;
                }
                o[2] && s.ops.pop(), s.trys.pop();
                continue;
            }
            a3 = n.call(t, s);
          } catch (t2) {
            a3 = [6, t2], r = 0;
          } finally {
            e = o = 0;
          }
        if (5 & a3[0])
          throw a3[1];
        return { value: a3[0] ? a3[1] : void 0, done: true };
      }([a2, u]);
    };
  }
}
function w(t, n, e) {
  if (e || 2 === arguments.length)
    for (var r, o = 0, i = n.length; o < i; o++)
      !r && o in n || (r || (r = Array.prototype.slice.call(n, 0, o)), r[o] = n[o]);
  return t.concat(r || Array.prototype.slice.call(n));
}
function L(t) {
  return [Math.abs(t.endPoint[0] - t.startPoint[0]), Math.abs(t.endPoint[1] - t.startPoint[1])];
}
function B(t) {
  return [t.startPoint[0] + (t.endPoint[0] - t.startPoint[0]) / 2, t.startPoint[1] + (t.endPoint[1] - t.startPoint[1]) / 2];
}
function I(t, n) {
  void 0 === n && (n = 1.5);
  var e = B(t), r = L(t), o = [n * r[0] / 2, n * r[1] / 2];
  return { startPoint: [e[0] - o[0], e[1] - o[1]], endPoint: [e[0] + o[0], e[1] + o[1]], palmLandmarks: t.palmLandmarks };
}
function C(t) {
  var n = B(t), e = L(t), r = Math.max.apply(Math, e) / 2;
  return { startPoint: [n[0] - r, n[1] - r], endPoint: [n[0] + r, n[1] + r], palmLandmarks: t.palmLandmarks };
}
function H(t, n) {
  var e = [t.endPoint[0] - t.startPoint[0], t.endPoint[1] - t.startPoint[1]], r = [e[0] * n[0], e[1] * n[1]];
  return { startPoint: [t.startPoint[0] + r[0], t.startPoint[1] + r[1]], endPoint: [t.endPoint[0] + r[0], t.endPoint[1] + r[1]], palmLandmarks: t.palmLandmarks };
}
var M = function() {
  function t(t2, n, o, i, s, a) {
    this.model = t2, this.width = n, this.height = o, this.iouThreshold = s, this.scoreThreshold = a, this.anchors = i.map(function(t3) {
      return [t3.x_center, t3.y_center];
    }), this.anchorsTensor = tensor2d(this.anchors), this.inputSizeTensor = tensor1d([n, o]), this.doubleInputSizeTensor = tensor1d([2 * n, 2 * o]);
  }
  return t.prototype.normalizeBoxes = function(t2) {
    var n = this;
    return tidy(function() {
      var e = slice(t2, [0, 0], [-1, 2]), r = slice(t2, [0, 2], [-1, 2]), o = add(div(e, n.inputSizeTensor), n.anchorsTensor), c = div(r, n.doubleInputSizeTensor), f = mul(sub(o, c), n.inputSizeTensor), l = mul(add(o, c), n.inputSizeTensor);
      return concat2d([f, l], 1);
    });
  }, t.prototype.normalizeLandmarks = function(t2, n) {
    var e = this;
    return tidy(function() {
      var r = add(div(reshape(t2, [-1, 7, 2]), e.inputSizeTensor), e.anchors[n]);
      return mul(r, e.inputSizeTensor);
    });
  }, t.prototype.getBoundingBoxes = function(t2) {
    return k(this, void 0, void 0, function() {
      var e, r, s, a, d, v, P, g, b, y, k2, w2, L2, B2, I2, C2 = this;
      return x(this, function(x2) {
        switch (x2.label) {
          case 0:
            return e = tidy(function() {
              return mul(sub(t2, 0.5), 2);
            }), "webgl" === getBackend() ? (s = env().get("WEBGL_PACK_DEPTHWISECONV"), env().set("WEBGL_PACK_DEPTHWISECONV", true), r = this.model.predict(e), env().set("WEBGL_PACK_DEPTHWISECONV", s)) : r = this.model.predict(e), a = squeeze(r), d = tidy(function() {
              return squeeze(sigmoid(slice(a, [0, 0], [-1, 1])));
            }), v = slice(a, [0, 1], [-1, 4]), P = this.normalizeBoxes(v), g = console.warn, console.warn = function() {
            }, b = image.nonMaxSuppression(P, d, 1, this.iouThreshold, this.scoreThreshold), console.warn = g, [4, b.array()];
          case 1:
            return y = x2.sent(), k2 = [e, r, b, a, P, v, d], 0 === y.length ? (k2.forEach(function(t3) {
              return t3.dispose();
            }), [2, null]) : (w2 = y[0], L2 = slice(P, [w2, 0], [1, -1]), B2 = slice(a, [w2, 5], [1, 14]), I2 = tidy(function() {
              return reshape(C2.normalizeLandmarks(B2, w2), [-1, 2]);
            }), k2.push(B2), k2.forEach(function(t3) {
              return t3.dispose();
            }), [2, { boxes: L2, palmLandmarks: I2 }]);
        }
      });
    });
  }, t.prototype.estimateHandBounds = function(t2) {
    return k(this, void 0, void 0, function() {
      var e, r, i, s, u, h, d, c, f = this;
      return x(this, function(l) {
        switch (l.label) {
          case 0:
            return e = t2.shape[1], r = t2.shape[2], i = tidy(function() {
              return div(image.resizeBilinear(t2, [f.width, f.height]), 255);
            }), [4, this.getBoundingBoxes(i)];
          case 1:
            return null === (s = l.sent()) ? (i.dispose(), [2, null]) : (u = s.boxes.arraySync(), h = u[0].slice(0, 2), d = u[0].slice(2, 4), c = s.palmLandmarks.arraySync(), i.dispose(), s.boxes.dispose(), s.palmLandmarks.dispose(), [2, (p = { startPoint: h, endPoint: d, palmLandmarks: c }, m = [r / this.width, e / this.height], { startPoint: [p.startPoint[0] * m[0], p.startPoint[1] * m[1]], endPoint: [p.endPoint[0] * m[0], p.endPoint[1] * m[1]], palmLandmarks: p.palmLandmarks.map(function(t3) {
              return [t3[0] * m[0], t3[1] * m[1]];
            }) })]);
        }
        var p, m;
      });
    });
  }, t;
}();
var T = { thumb: [1, 2, 3, 4], indexFinger: [5, 6, 7, 8], middleFinger: [9, 10, 11, 12], ringFinger: [13, 14, 15, 16], pinky: [17, 18, 19, 20], palmBase: [0] };
function E(t, n) {
  var e, r = Math.PI / 2 - Math.atan2(-(n[1] - t[1]), n[0] - t[0]);
  return (e = r) - 2 * Math.PI * Math.floor((e + Math.PI) / (2 * Math.PI));
}
var S = function(t, n) {
  return [[1, 0, t], [0, 1, n], [0, 0, 1]];
};
function O(t, n) {
  for (var e = 0, r = 0; r < t.length; r++)
    e += t[r] * n[r];
  return e;
}
function W(t, n) {
  for (var e = [], r = 0; r < t.length; r++)
    e.push(t[r][n]);
  return e;
}
function D(t, n) {
  for (var e = [], r = t.length, o = 0; o < r; o++) {
    e.push([]);
    for (var i = 0; i < r; i++)
      e[o].push(O(t[o], W(n, i)));
  }
  return e;
}
function z(t, n) {
  var e = Math.cos(t), r = Math.sin(t), o = [[e, -r, 0], [r, e, 0], [0, 0, 1]], i = D(S(n[0], n[1]), o);
  return D(i, S(-n[0], -n[1]));
}
function _(t, n) {
  return [O(t, n[0]), O(t, n[1])];
}
var R = [0, -0.4];
var j = [0, -0.1];
var V = [0, 5, 9, 13, 17, 1, 2];
var A = function() {
  function t(t2, n, e, r, o, i) {
    this.boundingBoxDetector = t2, this.meshDetector = n, this.meshWidth = e, this.meshHeight = r, this.maxContinuousChecks = o, this.detectionConfidence = i, this.regionsOfInterest = [], this.runsWithoutHandDetector = 0, this.maxHandsNumber = 1;
  }
  return t.prototype.getBoxForPalmLandmarks = function(t2, n) {
    var e = t2.map(function(t3) {
      return _(w(w([], t3, true), [1], false), n);
    });
    return I(C(H(this.calculateLandmarksBoundingBox(e), R)), 3);
  }, t.prototype.getBoxForHandLandmarks = function(t2) {
    for (var n = I(C(H(this.calculateLandmarksBoundingBox(t2), j)), 1.65), e = [], r = 0; r < V.length; r++)
      e.push(t2[V[r]].slice(0, 2));
    return n.palmLandmarks = e, n;
  }, t.prototype.transformRawCoords = function(t2, n, e, r) {
    var o, i, s, a, u = this, h = L(n), d = [h[0] / this.meshWidth, h[1] / this.meshHeight], c = t2.map(function(t3) {
      return [d[0] * (t3[0] - u.meshWidth / 2), d[1] * (t3[1] - u.meshHeight / 2), t3[2]];
    }), f = z(e, [0, 0]), l = c.map(function(t3) {
      return w(w([], _(t3, f), true), [t3[2]], false);
    }), p = (i = [[(o = r)[0][0], o[1][0]], [o[0][1], o[1][1]]], s = [o[0][2], o[1][2]], a = [-O(i[0], s), -O(i[1], s)], [i[0].concat(a[0]), i[1].concat(a[1]), [0, 0, 1]]), m = w(w([], B(n), true), [1], false), v = [O(m, p[0]), O(m, p[1])];
    return l.map(function(t3) {
      return [t3[0] + v[0], t3[1] + v[1], t3[2]];
    });
  }, t.prototype.estimateHand = function(t2) {
    return k(this, void 0, void 0, function() {
      var e, r, o, i, s, u, h, d, p, m, v, P, g, b, y, k2, w2, L2, I2, C2;
      return x(this, function(x2) {
        switch (x2.label) {
          case 0:
            return true !== (e = this.shouldUpdateRegionsOfInterest()) ? [3, 2] : [4, this.boundingBoxDetector.estimateHandBounds(t2)];
          case 1:
            return null === (r = x2.sent()) ? (t2.dispose(), this.regionsOfInterest = [], [2, null]) : (this.updateRegionsOfInterest(r, true), this.runsWithoutHandDetector = 0, [3, 3]);
          case 2:
            this.runsWithoutHandDetector++, x2.label = 3;
          case 3:
            return o = this.regionsOfInterest[0], i = E(o.palmLandmarks[0], o.palmLandmarks[2]), s = B(o), u = [s[0] / t2.shape[2], s[1] / t2.shape[1]], h = image.rotateWithOffset(t2, i, 0, u), d = z(-i, s), p = true === e ? this.getBoxForPalmLandmarks(o.palmLandmarks, d) : o, m = function(t3, e2, r2) {
              var o2 = e2.shape[1], i2 = e2.shape[2], s2 = [[t3.startPoint[1] / o2, t3.startPoint[0] / i2, t3.endPoint[1] / o2, t3.endPoint[0] / i2]];
              return image.cropAndResize(e2, s2, [0], r2);
            }(p, h, [this.meshWidth, this.meshHeight]), v = div(m, 255), m.dispose(), h.dispose(), "webgl" === getBackend() ? (g = env().get("WEBGL_PACK_DEPTHWISECONV"), env().set("WEBGL_PACK_DEPTHWISECONV", true), P = this.meshDetector.predict(v), env().set("WEBGL_PACK_DEPTHWISECONV", g)) : P = this.meshDetector.predict(v), b = P[0], y = P[1], v.dispose(), k2 = b.dataSync()[0], b.dispose(), k2 < this.detectionConfidence ? (y.dispose(), this.regionsOfInterest = [], [2, null]) : (w2 = reshape(y, [-1, 3]), L2 = w2.arraySync(), y.dispose(), w2.dispose(), I2 = this.transformRawCoords(L2, p, i, d), C2 = this.getBoxForHandLandmarks(I2), this.updateRegionsOfInterest(C2, false), [2, { landmarks: I2, handInViewConfidence: k2, boundingBox: { topLeft: C2.startPoint, bottomRight: C2.endPoint } }]);
        }
      });
    });
  }, t.prototype.calculateLandmarksBoundingBox = function(t2) {
    var n = t2.map(function(t3) {
      return t3[0];
    }), e = t2.map(function(t3) {
      return t3[1];
    });
    return { startPoint: [Math.min.apply(Math, n), Math.min.apply(Math, e)], endPoint: [Math.max.apply(Math, n), Math.max.apply(Math, e)] };
  }, t.prototype.updateRegionsOfInterest = function(t2, n) {
    if (n)
      this.regionsOfInterest = [t2];
    else {
      var e = this.regionsOfInterest[0], r = 0;
      if (null != e && null != e.startPoint) {
        var o = t2.startPoint, i = o[0], s = o[1], a = t2.endPoint, u = a[0], h = a[1], d = e.startPoint, c = d[0], f = d[1], l = e.endPoint, p = l[0], m = l[1], v = Math.max(i, c), P = Math.max(s, f), g = (Math.min(u, p) - v) * (Math.min(h, m) - P);
        r = g / ((u - i) * (h - s) + (p - c) * (m - s) - g);
      }
      this.regionsOfInterest[0] = r > 0.8 ? e : t2;
    }
  }, t.prototype.shouldUpdateRegionsOfInterest = function() {
    return this.regionsOfInterest.length !== this.maxHandsNumber || this.runsWithoutHandDetector >= this.maxContinuousChecks;
  }, t;
}();
function F() {
  return k(this, void 0, void 0, function() {
    return x(this, function(n) {
      return "https://tfhub.dev/mediapipe/tfjs-model/handdetector/1/default/1", [2, loadGraphModel("https://tfhub.dev/mediapipe/tfjs-model/handdetector/1/default/1", { fromTFHub: true })];
    });
  });
}
function N() {
  return k(this, void 0, void 0, function() {
    return x(this, function(n) {
      return "https://tfhub.dev/mediapipe/tfjs-model/handskeleton/1/default/1", [2, loadGraphModel("https://tfhub.dev/mediapipe/tfjs-model/handskeleton/1/default/1", { fromTFHub: true })];
    });
  });
}
function G() {
  return k(this, void 0, void 0, function() {
    return x(this, function(t) {
      return [2, util_exports.fetch("https://tfhub.dev/mediapipe/tfjs-model/handskeleton/1/default/1/anchors.json?tfjs-format=file").then(function(t2) {
        return t2.json();
      })];
    });
  });
}
function K(t) {
  var n = void 0 === t ? {} : t, e = n.maxContinuousChecks, r = void 0 === e ? 1 / 0 : e, o = n.detectionConfidence, i = void 0 === o ? 0.8 : o, s = n.iouThreshold, a = void 0 === s ? 0.3 : s, u = n.scoreThreshold, h = void 0 === u ? 0.5 : u;
  return k(this, void 0, void 0, function() {
    var t2, n2, e2, o2, s2, u2;
    return x(this, function(d) {
      switch (d.label) {
        case 0:
          return [4, Promise.all([G(), F(), N()])];
        case 1:
          return t2 = d.sent(), n2 = t2[0], e2 = t2[1], o2 = t2[2], s2 = new M(e2, 256, 256, n2, a, h), u2 = new A(s2, o2, 256, 256, r, i), [2, new U(u2)];
      }
    });
  });
}
var U = function() {
  function t(t2) {
    this.pipeline = t2;
  }
  return t.getAnnotations = function() {
    return T;
  }, t.prototype.estimateHands = function(t2, n) {
    return void 0 === n && (n = false), k(this, void 0, void 0, function() {
      var e, r, i, s, a, u, h, d, c;
      return x(this, function(f) {
        switch (f.label) {
          case 0:
            return e = function(t3) {
              return t3 instanceof Tensor ? [t3.shape[0], t3.shape[1]] : [t3.height, t3.width];
            }(t2), r = e[1], i = tidy(function() {
              return t2 instanceof Tensor || (t2 = browser_exports.fromPixels(t2)), expandDims(cast(t2, "float32"));
            }), [4, this.pipeline.estimateHand(i)];
          case 1:
            if (s = f.sent(), i.dispose(), null === s)
              return [2, []];
            for (a = s, true === n && (a = function(t3, n2) {
              var e2 = t3.handInViewConfidence, r2 = t3.landmarks, o = t3.boundingBox;
              return { handInViewConfidence: e2, landmarks: r2.map(function(t4) {
                return [n2 - 1 - t4[0], t4[1], t4[2]];
              }), boundingBox: { topLeft: [n2 - 1 - o.topLeft[0], o.topLeft[1]], bottomRight: [n2 - 1 - o.bottomRight[0], o.bottomRight[1]] } };
            }(s, r)), u = {}, h = 0, d = Object.keys(T); h < d.length; h++)
              c = d[h], u[c] = T[c].map(function(t3) {
                return a.landmarks[t3];
              });
            return [2, [{ handInViewConfidence: a.handInViewConfidence, boundingBox: a.boundingBox, landmarks: a.landmarks, annotations: u }]];
        }
      });
    });
  }, t;
}();
export {
  U as HandPose,
  K as load
};
/*! Bundled license information:

@tensorflow-models/handpose/dist/handpose.esm.js:
  (**
      * @license
      * Copyright 2023 Google LLC. All Rights Reserved.
      * Licensed under the Apache License, Version 2.0 (the "License");
      * you may not use this file except in compliance with the License.
      * You may obtain a copy of the License at
      *
      * http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing, software
      * distributed under the License is distributed on an "AS IS" BASIS,
      * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      * See the License for the specific language governing permissions and
      * limitations under the License.
      * =============================================================================
      *)
*/
//# sourceMappingURL=@tensorflow-models_handpose.js.map
